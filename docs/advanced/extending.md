# Расширение

Alpine имеет очень открытую кодовую базу, которая позволяет расширять её различными способами. Фактически, каждая доступная директива и магия в самом Alpine используют именно эти API. Теоретически вы можете восстановить всю функциональность Alpine, используя их самостоятельно.

<a name="lifecycle-concerns"></a>

## Проблемы жизненного цикла

Прежде чем мы углубимся в каждый отдельный API, давайте сначала поговорим о том, где в вашей кодовой базе вам следует использовать эти API.

Поскольку эти API влияют на то, как Alpine инициализирует страницу, их необходимо зарегистрировать ПОСЛЕ того, как Alpine будет загружен и доступен на странице, но ДО того, как он инициализирует саму страницу.

Существует два разных метода в зависимости от того, импортируете ли вы Alpine в пакет или включаете его напрямую через тег `<script>`. Давайте рассмотрим оба.

<a name="via-script-tag"></a>

### Через тег `script`

Если вы включаете Alpine через тег сценария, вам нужно будет зарегистрировать любой пользовательский код расширения внутри прослушивателя событий `alpine:init`.

Вот пример:

```html
<html>
  <script src="/js/alpine.js" defer></script>

  <div x-data x-foo></div>

  <script>
    document.addEventListener('alpine:init', () => {
        Alpine.directive('foo', ...)
    })
  </script>
</html>
```

Если вы хотите извлечь код расширения во внешний файл, вам необходимо убедиться, что тег `<script>` файла расположен ДО Alpine, например:

```html
<html>
  <script src="/js/foo.js" defer></script>
  <script src="/js/alpine.js" defer></script>

  <div x-data x-foo></div>
</html>
```

<a name="via-npm"></a>

### Через модуль NPM

Если вы импортировали Alpine в пакет, вам необходимо убедиться, что вы регистрируете любой код расширения ПОСЛЕ импорта глобального объекта Alpine и ПЕРЕД вызовом `Alpine.start()` для инициализации Alpine. Например:

```js
import Alpine from 'alpinejs'

Alpine.directive('foo', ...)

window.Alpine = Alpine
window.Alpine.start()
```

Теперь, когда мы знаем, где использовать эти API расширений, давайте более подробно рассмотрим, как использовать каждый из них:

<a name="custom-directives"></a>

## Пользовательские директивы

Alpine позволяет вам регистрировать ваши собственные директивы с помощью API `Alpine.directive()`.

<a name="method-signature"></a>

### Сигнатура метода

```js
Alpine.directive(
  '[name]',
  (el, { value, modifiers, expression }, { Alpine, effect, cleanup }) => {}
);
```

| &nbsp;     | &nbsp;                                                                                                                                  |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| name       | Имя директивы. Например, имя «foo» будет использоваться как `x-foo`                                                                     |
| el         | Элемент DOM, к которому добавляется директива                                                                                           |
| value      | Если предусмотрено, часть директивы после двоеточия. Пример: `'bar'` в `x-foo:bar`                                                      |
| modifiers  | Массив дополнений к директиве, разделенных точками. Пример: `['baz', 'lob']` из `x-foo.baz.lob`                                         |
| expression | Часть значения атрибута директивы. Пример: `law` из `x-foo="law"`                                                                       |
| Alpine     | Глобальный объект Alpine                                                                                                                |
| effect     | Функция для создания реактивных эффектов, которые будут автоматически очищаться после удаления этой директивы из DOM.                   |
| cleanup    | Функция, в которую вы можете передать специальные обратные вызовы, которая будет выполняться, когда эта директива будет удалена из DOM. |

<a name="simple-example"></a>

### Простой пример

Вот пример простой директивы, которую мы собираемся создать, под названием `x-uppercase`:

```js
Alpine.directive('uppercase', (el) => {
  el.textContent = el.textContent.toUpperCase();
});
```

```html
<div x-data>
  <span x-uppercase>Привет, мир!</span>
</div>
```

<a name="evaluating-expressions"></a>

### Выполнение выражений

При регистрации пользовательской директивы вам может потребоваться выполнить предоставленное пользователем выражение JavaScript:

Например, предположим, что вы хотите создать специальную директиву в качестве ярлыка для `console.log()`. Что-то вроде:

```html
<div x-data="{ message: 'Привет, мир!' }">
  <div x-log="message"></div>
</div>
```

Вам необходимо получить фактическое значение сообщения, вычислив его как выражение JavaScript с областью действия x-data.

К счастью, Alpine предоставляет свою систему для выполнения выражений JavaScript с помощью API `evaluate()`. Вот пример:

```js
Alpine.directive('log', (el, { expression }, { evaluate }) => {
  // expression === 'message'

  console.log(evaluate(expression));
});
```

Теперь, когда Alpine инициализирует `<div x-log...>`, он извлекает выражение, переданное в директиву (в данном случае «message»), и рассчитывает его в контексте области действия компонента Alpine текущего элемента.

<a name="introducing-reactivity"></a>

### Представляем реактивность

Основываясь на предыдущем примере с `x-log`, предположим, что мы хотим, чтобы `x-log` регистрировал значение `message`, а также регистрировал его, если значение изменяется.

Учитывая следующий шаблон:

```html
<div x-data="{ message: 'Привет, мир!' }">
  <div x-log="message"></div>

  <button @click="message = 'yolo'">Изменить</button>
</div>
```

Мы хотим установить начальное значение переменной _message_ как «Привет, мир!», а при нажатии на `<button>` задаём новое значение — «yolo».

Для этого мы можем скорректировать реализацию `x-log` и ввести два новых API: `evaluateLater()` и `effect()`:

```js
Alpine.directive('log', (el, { expression }, { evaluateLater, effect }) => {
  let getThingToLog = evaluateLater(expression);

  effect(() => {
    getThingToLog((thingToLog) => {
      console.log(thingToLog);
    });
  });
});
```

Давайте построчно пройдемся по приведенному выше коду.

```js
let getThingToLog = evaluateLater(expression);
```

Здесь вместо того, чтобы сразу анализировать `message` и извлекать результат, мы преобразуем строковое выражение («message») в фактическую функцию JavaScript, которую можно запустить в любой момент. Если вы собираетесь анализировать выражение JavaScript более одного раза, настоятельно рекомендуется сначала сгенерировать функцию JavaScript и использовать её, а не вызывать `evaluate()` напрямую. Причина в том, что процесс интерпретации обычной строки как функции JavaScript является дорогостоящим и его следует избегать, когда в этом нет необходимости.

```js
effect(() => {
    ...
})
```

Передавая в `effect()` обратный вызов, мы указываем Alpine на необходимость немедленного выполнения этого вызова, а затем отслеживания всех зависимостей, которые он использует (свойства `x-data`, например, `message` в нашем случае). Теперь, как только одна из зависимостей изменится, этот обратный вызов будет запущен повторно. Это и дает нам нашу «реактивность».

Вы можете узнать эту функциональность из `x-effect`. Под капотом находится один и тот же механизм.

Вы также можете заметить, что `Alpine.effect()` существует, и удивиться, почему мы не используем его здесь. Причина в том, что функция `effect`, передаваемая через параметр _method_, имеет специальную функциональность, которая очищается при удалении директивы со страницы по какой-либо причине.

Например, если по какой-то причине элемент с `x-log` был удален со страницы, то при изменении свойства `message` с помощью `effect()` вместо `Alpine.effect()` значение больше не будет выводиться в консоль.

[→ Подробнее о реактивности в Alpine](../advanced/reactivity.md)

```js
getThingToLog((thingToLog) => {
  console.log(thingToLog);
});
```

Теперь вызовем `getThingToLog`, который, если вы помните, является собственно JavaScript-функцией, представляющей собой версию строкового выражения: "message".

Можно было бы ожидать, что `getThingToCall()` сразу же вернет результат, но вместо этого Alpine требует передать обратный вызов для получения результата.

Причиной этого является поддержка асинхронных выражений, таких как `await getMessage()`. Передавая обратный вызов «получателя» вместо немедленного получения результата, вы также позволяете своей директиве работать с асинхронными выражениями.

[→ Подробнее об `async` в Alpine](../advanced/async.md)

<a name="cleaning-up"></a>

### Очистка

Допустим, вам нужно зарегистрировать прослушиватель событий из пользовательской директивы. После того, как эта директива по какой-либо причине будет удалена со страницы, вам также потребуется удалить прослушиватель событий.

Alpine упрощает эту задачу, предоставляя вам функцию «очистки» при регистрации пользовательских директив.

Вот пример:

```js
Alpine.directive('...', (el, {}, { cleanup }) => {
  let handler = () => {};

  window.addEventListener('click', handler);

  cleanup(() => {
    window.removeEventListener('click', handler);
  });
});
```

Теперь, если из этого элемента будет удалена директива или сам элемент будет удален, прослушиватель событий также будет удален.

<a name="custom-order"></a>

### Пользовательский порядок

По умолчанию любая новая директива будет выполняться после большинства стандартных (за исключением `x-teleport`). Обычно это приемлемо, но иногда вам может потребоваться запустить пользовательскую директиву перед другой конкретной.
Этого можно добиться, связав функцию `.before()` с `Alpine.directive()` и указав, какая директива должна выполняться после вашей пользовательской.

```js
Alpine.directive('foo', (el, { value, modifiers, expression }) => {
  Alpine.addScopeToNode(el, { foo: 'bar' });
}).before('bind');
```

```html
<div x-data>
  <span x-foo x-bind:foo="foo"></span>
</div>
```

!!! note "Примечание"

    Обратите внимание: имя директивы должно быть записано без префикса `x-` (или любого другого пользовательского префикса, который вы можете использовать).

<a name="custom-magics"></a>

## Пользовательская магия

Alpine позволяет вам регистрировать пользовательские «магии» (свойства или методы) с помощью `Alpine.magic()`. Любая магия, которую вы зарегистрируете, будет доступна для всего кода Alpine вашего приложения с префиксом `$`.

<a name="method-signature"></a>

### Сигнатура метода

```js
Alpine.magic('[name]', (el, { Alpine }) => {});
```

| &nbsp; | &nbsp;                                                                      |
| ------ | --------------------------------------------------------------------------- |
| name   | Имя магического метода. Например, имя «foo» будет использоваться как `$foo` |
| el     | Элемент DOM, из которого была активирована магия                            |
| Alpine | Глобальный объект Alpine                                                    |

<a name="magic-properties"></a>

### Магические свойства

Вот базовый пример магического помощника «$now», позволяющего легко получить текущее время из любой точки Alpine:

```js
Alpine.magic('now', () => {
  return new Date().toLocaleTimeString();
});
```

```html
<span x-text="$now"></span>
```

Теперь тег `<span>` будет содержать текущее время, что-то вроде «12:00:00 PM».

Как вы можете видеть, `$now` ведет себя как статическое свойство, но на самом деле внутри него находится геттер, который выполняет оценку каждый раз, когда к свойству обращаются.

Благодаря этому вы можете реализовать магические «функции», возвращая функцию из геттера.

<a name="magic-functions"></a>

### Магические функции

Например, если бы мы хотели создать магическую функцию `$clipboard()`, которая принимает строку для копирования в буфер обмена, мы могли бы реализовать её следующим образом:

```js
Alpine.magic('clipboard', () => {
  return (subject) => navigator.clipboard.writeText(subject);
});
```

```html
<button @click="$clipboard('привет, мир')">Копировать «Привет, мир»</button>
```

Теперь, когда доступ к `$clipboard` возвращает саму функцию, мы можем немедленно вызвать её и передать ей аргумент, как мы видим в шаблоне с `$clipboard('привет, мир')`.

Если хотите, вы можете использовать более краткий синтаксис (функция с двойной стрелкой) для возврата функции из функции:

```js
Alpine.magic('clipboard', () => (subject) => {
  navigator.clipboard.writeText(subject);
});
```

<a name="writing-and-sharing-plugins"></a>

## Написание и обмен плагинами

Теперь вы должны убедиться, насколько удобно и просто регистрировать свои собственные директивы и магические функции в вашем приложении, но как насчет того, чтобы поделиться этой функциональностью с другими через пакет NPM или что-то в этом роде?

Вы можете быстро начать работу с официальным пакетом плагинов Alpine. Это так же просто, как клонировать репозиторий и запустить `npm install && npm run build`, чтобы создать плагин.

В демонстрационных целях давайте создадим с нуля воображаемый плагин Alpine под названием `Foo`, который включает в себя как директиву (`x-foo`), так и магию (`$foo`).

Мы начнем создавать этот плагин для использования в виде простого тега `<script>` вместе с Alpine, затем выровняем его до модуля для импорта в пакет:

<a name="script-include"></a>

### Включение через script

Давайте начнем в обратном порядке и посмотрим, как наш плагин будет включен в проект:

```html
<html>
    <script src="/js/foo.js" defer></script>
    <script src="/js/alpine.js" defer></script>

    <div x-data x-init="$foo()">
        <span x-foo="'привет, мир'">
    </div>
</html>
```

Обратите внимание, что наш скрипт включен ДО самого Alpine. Это важно, иначе Alpine уже будет инициализирован к моменту загрузки нашего плагина.

Теперь давайте заглянем внутрь содержимого `/js/foo.js`:

```js
document.addEventListener('alpine:init', () => {
    window.Alpine.directive('foo', ...)

    window.Alpine.magic('foo', ...)
})
```

Вот и всё! Создание плагина для включения через тег сценария с Alpine чрезвычайно просто.

<a name="bundle-module"></a>

### Пакетный модуль

Теперь предположим, что вы хотите создать плагин, который кто-то сможет установить через NPM и включить в свой пакет.

Как и в последнем примере, мы рассмотрим всё в обратном порядке, начиная с того, как будет выглядеть использование этого плагина:

```js
import Alpine from 'alpinejs';

import foo from 'foo';
Alpine.plugin(foo);

window.Alpine = Alpine;
window.Alpine.start();
```

Здесь вы заметите новый API: `Alpine.plugin()`. Это удобный метод, который Alpine предоставляет, чтобы пользователям вашего плагина не приходилось самостоятельно регистрировать несколько различных директив и магических функций.

Теперь давайте посмотрим на исходный код плагина и на то, что экспортируется из `foo`:

```js
export default function (Alpine) {
    Alpine.directive('foo', ...)
    Alpine.magic('foo', ...)
}
```

Вы увидите, что `Alpine.plugin` невероятно прост. Он принимает обратный вызов и немедленно вызывает его, предоставляя глобальный объект `Alpine` в качестве параметра для использования внутри него.

Затем вы можете расширять Alpine по своему усмотрению.
