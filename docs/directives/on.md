# x-on

`x-on` позволяет вам легко запускать код для отправленных событий DOM.

Вот пример простой кнопки, при нажатии на которую отображается предупреждение.

```html
<button x-on:click="alert('Привет, мир!')">Скажи привет</button>
```

!!! note "Примечание"

    `x-on` может прослушивать только события с именами в нижнем регистре, поскольку атрибуты HTML нечувствительны к регистру. Написание `x-on:CLICK` будет прослушивать событие с именем `click`. Если вам нужно прослушивать пользовательское событие с именем CamelCase, вы можете использовать модификатор [`.camel`](#camel), чтобы обойти это ограничение. Или же можно использовать [`x-bind`](bind.md#bind-directives), чтобы прикрепить директиву `x-on` к элементу в коде JavaScript (где регистр будет сохранен).

<a name="shorthand-syntax"></a>

## Сокращённый синтаксис

Если `x-on:` вам кажется слишком многословным, вы можете использовать сокращённый синтаксис: `@`.

Вот тот же компонент, что и выше, но с использованием сокращённого синтаксиса:

```html
<button @click="alert('Привет, мир!')">Скажи привет</button>
```

<a name="the-event-object"></a>

## Объект события

Если вы хотите получить доступ к собственному объекту события JavaScript из вашего выражения, вы можете использовать магическое свойство Alpine `$event`.

```html
<button @click="alert($event.target.getAttribute('message'))" message="Привет, мир!">
  Скажи привет
</button>
```

Кроме того, Alpine также передает объект события всем методам, на которые он ссылается, без завершающих круглых скобок. Например:

```html
<button @click="handleClick">...</button>

<script>
  function handleClick(e) {
    // Теперь вы можете напрямую получить доступ к объекту события (e).
  }
</script>
```

<a name="keyboard-events"></a>

## События клавиатуры

Alpine позволяет легко прослушивать события `keydown` и `keyup` на определенных клавишах.

Вот пример прослушивания клавиши `Enter` внутри элемента ввода.

```html
<input type="text" @keyup.enter="alert('Отправлено!')" />
```

Вы также можете объединить эти ключевые модификаторы для создания более сложных прослушивателей.

Вот прослушиватель, который запускается, когда удерживается клавиша `Shift` и нажимается `Enter`, но не когда только нажимается `Enter`.

```html
<input type="text" @keyup.shift.enter="alert('Отправлено!')" />
```

Вы можете напрямую использовать любые действительные имена ключей, предоставленные через [`KeyboardEvent.key`](https://developer.mozilla.org/ru/docs/Web/API/UI_Events/Keyboard_event_key_values), в качестве модификаторов, преобразовав их в шашлычную нотацию (`kebab-case`).

```html
<input type="text" @keyup.page-down="alert('Отправлено!')" />
```

Для удобства ниже приведён список общих ключей, которые вы, возможно, захотите прослушать.

| Модификатор                    | Клавиша клавиатуры                   |
| ------------------------------ | ------------------------------------ |
| `.shift`                       | Shift                                |
| `.enter`                       | Enter                                |
| `.space`                       | Space                                |
| `.ctrl`                        | Ctrl                                 |
| `.cmd`                         | Cmd                                  |
| `.meta`                        | Cmd в Mac, клавиша Windows в Windows |
| `.alt`                         | Alt                                  |
| `.up` `.down` `.left` `.right` | стрелки Up/Down/Left/Right           |
| `.escape`                      | Escape                               |
| `.tab`                         | Tab                                  |
| `.caps-lock`                   | Caps Lock                            |
| `.equal`                       | Equal, `=`                           |
| `.period`                      | Period, `.`                          |
| `.slash`                       | Forward Slash, `/`                   |

<a name="custom-events"></a>

## Пользовательские события

Прослушиватели событий Alpine — это оболочка для собственных прослушивателей событий DOM. Таким образом, они могут прослушивать ЛЮБЫЕ события DOM, включая пользовательские события.

Вот пример компонента, который отправляет пользовательское событие DOM и также прослушивает его.

```html
<div x-data @foo="alert('Кнопка была нажата!')">
  <button @click="$event.target.dispatchEvent(new CustomEvent('foo', { bubbles: true }))">
    ...
  </button>
</div>
```

При нажатии кнопки будет вызван прослушиватель `@foo`.

Поскольку API `.dispatchEvent` является многословным, Alpine предлагает хелпер `$dispatch` для упрощения работы.

Вот тот же компонент, переписанный с помощью магического свойства `$dispatch`:

```html
<div x-data @foo="alert('Кнопка была нажата!')">
  <button @click="$dispatch('foo')">...</button>
</div>
```

[→ Подробнее о `$dispatch`](../magics/dispatch.md)

<a name="modifiers"></a>

## Модификаторы

Alpine предлагает ряд модификаторов директив для настройки поведения прослушивателей событий.

<a name="prevent"></a>

### .prevent

`.prevent` эквивалентен вызову `.preventDefault()` внутри прослушивателя объекта события браузера.

```html
<form @submit.prevent="console.log('отправлено')" action="/foo">
  <button>Отправить</button>
</form>
```

В приведенном выше примере с `.prevent` нажатие кнопки НЕ приведет к отправке формы в конечную точку `/foo`. Вместо этого прослушиватель Alpine обработает его и «предотвратит» дальнейшую обработку события.

<a name="stop"></a>

### .stop

Подобно `.prevent`, `.stop` является эквивалентом вызова `.stopPropagation()` внутри прослушивателя объекта события браузера.

```html
<div @click="console.log('Вы не увидите это сообщение')">
  <button @click.stop>Нажми меня</button>
</div>
```

В приведенном выше примере нажатие кнопки НЕ зарегистрирует сообщение. Это связано с тем, что мы немедленно прекращаем распространение события и не позволяем ему «всплывать» до `<div>` с прослушивателем `@click`.

<a name="outside"></a>

### .outside

`.outside` — это удобный помощник для прослушивания щелчка за пределами элемента, к которому он прикреплён. Вот простой пример компонента раскрывающегося списка:

```html
<div x-data="{ open: false }">
  <button @click="open = !open">Переключить</button>

  <div x-show="open" @click.outside="open = false">Содержимое...</div>
</div>
```

В приведенном выше примере после отображения содержимого раскрывающегося списка нажатием кнопки «Переключить» вы можете закрыть раскрывающийся список, щелкнув в любом месте страницы за пределами содержимого.

Это связано с тем, что `.outside` прослушивает клики, которые НЕ исходят от элемента, на котором он зарегистрирован.

!!! note "Примечание"

    Стоит отметить, что выражение `.outside` будет оцениваться только тогда, когда элемент, для которого оно зарегистрировано, виден на странице. В противном случае возникнут неприятные условия гонки, когда нажатие кнопки «Переключить» также приведет к срабатыванию обработчика `@click.outside`, когда он невидим.

<a name="window"></a>

### .window

Если присутствует модификатор `.window`, Alpine зарегистрирует прослушиватель событий в корневом объекте `window` на странице, а не в самом элементе:

```html
<div @keyup.escape.window="...">...</div>
```

Приведенный выше фрагмент будет прослушивать нажатие клавиши «Escape» В ЛЮБОМ месте на странице.

Добавление `.window` к слушателям чрезвычайно полезно в случаях, когда небольшая часть вашей разметки связана с событиями, происходящими на всей странице.

<a name="document"></a>

### .document

`.document` работает аналогично `.window`, только он регистрирует слушателей в глобальном `document`, а не в глобальном `window`.

<a name="once"></a>

### .once

Добавляя `.once` к прослушивателю, вы гарантируете, что обработчик будет вызываться только ОДИН РАЗ:

```html
<button @click.once="console.log('Я появлюсь в логе только один раз')">...</button>
```

<a name="debounce"></a>

### .debounce

Иногда полезно «отключить» обработчик событий, чтобы он вызывался только после определенного периода бездействия (по умолчанию 250 миллисекунд).

Например, если у вас есть поле поиска, которое запускает сетевые запросы по мере того, как пользователь вводит его, добавление программного отключения предотвратит запуск сетевых запросов при каждом нажатии клавиши.

```html
<input @input.debounce="fetchResults" />
```

Теперь вместо вызова `fetchResults` после каждого нажатия клавиши, `fetchResults` будет вызываться только после 250 миллисекунд отсутствия нажатий клавиш.

Если вы хотите увеличить или сократить время устранения дребезга, вы можете сделать это, проставив продолжительность после модификатора `.debounce` следующим образом:

```html
<input @input.debounce.500ms="fetchResults" />
```

Теперь `fetchResults` будет вызываться только после 500 миллисекунд бездействия.

<a name="throttle"></a>

### .throttle

`.throttle` похож на `.debounce`, за исключением того, что он будет вызывать вызов обработчика каждые 250 миллисекунд вместо того, чтобы откладывать его на неопределенный срок.

Это полезно в случаях, когда могут повторяться и длиться события, и использование `.debounce` не будет работать, потому что вы все равно хотите время от времени обрабатывать событие.

Например:

```html
<div @scroll.window.throttle="handleScroll">...</div>
```

Приведенный выше пример — отличный вариант использования регулирования. Без `.throttle` метод `handleScroll` будет запускаться сотни раз, когда пользователь прокручивает страницу вниз. Это может сильно замедлить работу сайта. Добавляя `.throttle`, мы гарантируем, что `handleScroll` будет вызываться каждые 250 миллисекунд.

Как и в случае с `.debounce`, вы можете добавить собственную длительность регулируемого события:

```html
<div @scroll.window.throttle.750ms="handleScroll">...</div>
```

Теперь `handleScroll` будет вызываться каждые 750 миллисекунд.

<a name="self"></a>

### .self

Добавляя `.self` к прослушивателю событий, вы гарантируете, что событие возникло в элементе, в котором оно объявлено, а не в дочернем элементе.

```html
<button @click.self="handleClick">
  Нажми меня

  <img src="..." />
</button>
```

В приведенном выше примере у нас есть тег `<img>` внутри тега `<button>`. Обычно любой щелчок, происходящий внутри элемента `<button>` (например, в `<img>`), будет обнаружен прослушивателем `@click` на кнопке.

Однако в этом случае, поскольку мы добавили `.self`, только нажатие на кнопку вызовет `handleClick`. Не будут обрабатываться только клики, происходящие на элементе `<img>`.

<a name="camel"></a>

### .camel

```html
<div @custom-event.camel="handleCustomEvent">...</div>
```

Иногда вам может потребоваться прослушивать события camelCased, такие как `customEvent` в нашем примере. Поскольку camelCasing внутри HTML-атрибутов не поддерживается, Alpine необходимо добавить модификатор `.camel` для внутреннего использования camelCase имени события.

Добавив .camel в приведенном выше примере, Alpine теперь прослушивает `customEvent` вместо `custom-event`.

<a name="dot"></a>

### .dot

```html
<div @custom-event.dot="handleCustomEvent">...</div>
```

Подобно модификатору `.camelCase`, могут возникнуть ситуации, когда вы захотите прослушивать события, в имени которых есть точки (например, `custom.event`). Поскольку точки в названии события зарезервированы Alpine, вам необходимо писать их через тире и добавлять модификатор `.dot`.

В приведенном выше примере кода `custom-event.dot` будет соответствовать имени события `custom.event`.

<a name="passive"></a>

### .passive

Браузеры оптимизируют прокрутку страниц, чтобы она была быстрой и плавной, даже когда на странице выполняется JavaScript. Однако неправильно реализованные прослушиватели касаний и прокруток могут заблокировать эту оптимизацию и привести к снижению производительности сайта.

Если вы прослушиваете события касания, важно добавить к вашим слушателям `.passive`, чтобы не блокировать производительность прокрутки.

```html
<div @touchstart.passive="...">...</div>
```

[→ Подробнее о пассивных слушателях](https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener)

### .capture

Добавьте этот модификатор, если вы хотите выполнить этот прослушиватель на этапе захвата события, например, до того, как событие перейдёт от целевого элемента вверх по DOM.

```html
<div @click.capture="console.log('Я зарегистрируюсь первым')">
  <button @click="console.log('Я зарегистрируюсь вторым')"></button>
</div>
```

[→ Подробнее о фазе захвата и всплытия событий](https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener#usecapture)
